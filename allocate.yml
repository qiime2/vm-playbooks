---

- name: allocate AWS resources
  hosts: localhost
  connection: local
  vars_files:
    - vars.yml
  tasks:
    - name: create vpc
      ec2_vpc:
        state: present
        internet_gateway: True
        cidr_block: "{{ vpc_cidr_block }}"
        resource_tags:
          Name: "{{ workshop_name }}"
          Environment: "{{ workshop_name }}"
        region: "{{ ec2_region }}"
        subnets:
          - cidr: "{{ vpc_cidr_block }}"
            resource_tags:
              Name: "{{ workshop_name }} subnet"
        route_tables:
          - subnets:
            - "{{ vpc_cidr_block }}"
            routes:
              - dest: 0.0.0.0/0
                gw: igw
      register: vpc

    - name: get subnet
      ec2_vpc_subnet:
        vpc_id: "{{ vpc.vpc_id }}"
        region: "{{ ec2_region }}"
        cidr: "{{ vpc_cidr_block }}"
        resource_tags:
          Name: "{{ workshop_name }} subnet"
        state: present
      register: subnet

    - name: create security groups
      ec2_group:
        name: "{{ item.name }}"
        description: "{{ item.desc }}"
        rules: "{{ item.rules }}"
        region: "{{ ec2_region }}"
        vpc_id: "{{ vpc.vpc_id }}"
        state: present
      with_items: "{{ security_groups }}"

    - name: create keypair
      ec2_key:
        name: "{{ workshop_name }}"
        region: "{{ ec2_region }}"
        state: present
      register: key

    - name: save keypair to localhost
      copy:
        content: "{{ key.key.private_key }}"
        dest: "./{{ workshop_key_fn }}"
        mode: 0600
      when: key.changed

    - name: allocate jump host instance
      ec2:
        region: "{{ ec2_region }}"
        keypair: "{{ key.key.name }}"
        group: "{{ item.group }}"
        vpc_subnet_id: "{{ subnet.subnet.id }}"
        instance_type: "{{ item.instance_type }}"
        image: "{{ item.image }}"
        instance_tags: "{{ item.instance_tags }}"
        exact_count: "{{ item.exact_count }}"
        count_tag: "{{ item.count_tag }}"
        wait: True
      with_items: "{{ ec2_jump_host_instances }}"

    - name: get jump host info
      ec2_remote_facts:
        region: "{{ ec2_region }}"
        filters:
          instance.group-name: "{{ group_name }}"
          "tag:Name": "{{ jump_host_name }}"
      register: jump_hosts

    - name: assign elastic ip to jump host
      ec2_eip:
        region: "{{ ec2_region }}"
        device_id: "{{ jump_hosts.instances[0].id }}"
        ip: "{{ eip }}"

    - name: add jump host to inventory
      add_host:
        name: "{{ eip }}"
        groups: jump_hosts, all_hosts

    - name: allocate ebs
      ec2_vol:
        region: "{{ ec2_region }}"
        name: "{{ workshop_name }}"
        instance: "{{ jump_hosts.instances[0].id }}"
        volume_size: 8
        volume_type: gp2
        device_name: /dev/xvdb
        state: present
      register: ebs_vol

    - name: allocate compute instances
      ec2:
        region: "{{ ec2_region }}"
        keypair: "{{ key.key.name }}"
        group: "{{ item.group }}"
        vpc_subnet_id: "{{ subnet.subnet.id }}"
        instance_type: "{{ item.instance_type }}"
        image: "{{ item.image }}"
        instance_tags: "{{ item.instance_tags }}"
        exact_count: "{{ item.exact_count }}"
        count_tag: "{{ item.count_tag }}"
        assign_public_ip: True
        wait: True
      register: compute_hosts
      with_items: "{{ ec2_compute_instances }}"

    - name: add compute hosts to inventory
      add_host:
        name: "{{ item.1.public_ip }}"
        groups: all_hosts, compute_hosts
      with_subelements:
        - "{{ compute_hosts.results }}"
        - tagged_instances

    - name: add vars to dynamic groups
      add_host:
        name: "{{ item.1 }}"
        groups: compute_hosts
        grp: "worker{{ item.0 }}"
      with_indexed_items: "{{ groups['compute_hosts'] }}"

    - name: check if users files already exist
      stat:
        path: roster.json
      register: roster

    - name: generate account info
      command: "python {{ playbook_dir }}/generate_accts.py '{{ ec2_compute_instances | to_json }}'"
      when: not roster.stat.exists

    - pause: seconds=60

- hosts: all_hosts
  remote_user: ubuntu
  gather_facts: False
  tasks:
    - name: bootstrap python
      raw: sudo apt-get install -y python

- hosts: all_hosts
  remote_user: ubuntu
  become: True
  vars_files:
    - vars.yml
  tasks:

    - name: update all packages to the latest version
      apt:
        upgrade: dist

    - name: create groups
      group:
        name: "{{ hostvars[item]['grp'] }}"
        state: present
      with_items: "{{ groups['compute_hosts'] }}"

    - name: set up ssh (general)
      lineinfile:
        dest: /etc/ssh/sshd_config
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
      with_items:
        - { regexp: '^PasswordAuthentication.*$', line: 'PasswordAuthentication yes' }
        - { regexp: '^.*Port.*$', line: 'Port 22' }

    - name: restart ssh
      service:
        name: ssh
        state: restarted

- hosts: jump_hosts
  remote_user: ubuntu
  become: True
  vars_files:
    - vars.yml
  vars:
    users: "{{ lookup('file', 'roster.json') | from_json }}"
  tasks:
    - name: set up prereqs
      apt:
        name: "{{ item }}"
        state: latest
      with_items:
        - nginx
        - nfs-common
        - nfs-kernel-server

    - name: create mount point
      file:
        path: /mnt/home
        state: directory
        mode: 0777
        owner: ubuntu
        group: ubuntu

    - name: prep shared drive filesystem
      filesystem:
        fstype: ext4
        dev: /dev/xvdb

    - name: mount ebs
      mount:
        name: /mnt/home
        src: /dev/xvdb
        fstype: auto
        state: mounted

    - name: set up nfs server
      lineinfile:
        dest: /etc/exports
        insertafter: EOF
        line: "/mnt/home {{ vpc_cidr_block }}(rw,nohide,fsid=0,insecure,no_subtree_check,async)"

    - name: set up /etc/skel/.bashrc
      lineinfile:
        dest: /etc/skel/.bashrc
        line: "{{ item }}"
      with_items:
        - export PATH="/mnt/home/miniconda3/bin:$PATH"
        - source tab-qiime

    - name: create matplotlib config dirs
      file:
        path: "{{ item.path }}"
        state: "{{ item.state }}"
      with_items:
        - { path: '/etc/skel/.config', state: 'directory' }
        - { path: '/etc/skel/.config/matplotlib', state: 'directory' }
        - { path: '/etc/skel/.config/matplotlib/matplotlibrc', state: 'touch' }

    - name: set up /etc/skel/.config/matplotlib/matplotlibrc
      lineinfile:
        dest: /etc/skel/.config/matplotlib/matplotlibrc
        line: "{{ item }}"
      with_items:
        - "backend: agg"

    - name: create user accounts
      user:
        name: "{{ item.name }}"
        password: "{{ item.hash }}"
        group: "{{ item.group }}"
        uid: "{{ item.uid }}"
        shell: /bin/bash
        createhome: True
        home: "/mnt/home/{{ item.name }}"
      with_items: "{{ users }}"

    - name: configure ssh for jumping
      blockinfile:
        dest: /etc/ssh/sshd_config
        marker: "# {mark} ANSIBLE MANAGED BLOCK - {{ item }}"
        block: |
          Match Group {{ hostvars[item]['grp'] }}
              ForceCommand ssh {{ item }}
      with_items: "{{ groups['compute_hosts'] }}"

    - name: check if miniconda3 dir exists
      stat:
        path: /mnt/home/miniconda3
      register: miniconda

    - name: download miniconda
      get_url:
        url: https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh
        dest: miniconda.sh
        mode: u+rx
      when: not miniconda.stat.exists

    - name: install miniconda
      command: "./miniconda.sh -b -p /mnt/home/miniconda3"
      when: not miniconda.stat.exists

    - name: install matplotlib
      command: conda install matplotlib==1.5.1 -y
      environment:
        PATH: /mnt/home/miniconda3/bin:$PATH

    - name: install qiime, q2cli, q2-types, and q2-feature-table
      command: conda install -c qiime2 qiime q2cli q2-types q2-feature-table -y
      environment:
        PATH: /mnt/home/miniconda3/bin:$PATH

    - name: install q2-diversity, q2-emperor, emperor
      command: conda install -c qiime2 -c conda-forge q2-diversity q2-emperor emperor=1.0.0beta5 -y
      environment:
        PATH: /mnt/home/miniconda3/bin:$PATH

    - name: install dada2, mafft
      command: conda install -c bioconda -c r bioconductor-dada2 mafft -y
      environment:
        PATH: /mnt/home/miniconda3/bin:$PATH

    - name: install fasttree
      command: conda install -c biocore fasttree -y
      environment:
        PATH: /mnt/home/miniconda3/bin:$PATH

    - name: install q2-deumx, q2-alignment, q2-phylogeny, q2-dada2, q2-composition, q2-taxa, q2-feature-classifier
      command: conda install -c qiime2 q2-demux q2-alignment q2-phylogeny q2-dada2 q2-composition q2-taxa q2-feature-classifier -y
      environment:
        PATH: /mnt/home/miniconda3/bin:$PATH

    - name: restart ssh and nfs
      service:
        name: "{{ item }}"
        state: restarted
      with_items:
        - ssh
        - nfs-kernel-server

- hosts: compute_hosts
  remote_user: ubuntu
  become: True
  vars_files:
    - vars.yml
  vars:
    users: "{{ lookup('file', 'roster.json') | from_json }}"
  tasks:
    - name: set up prereqs
      apt:
        name: "{{ item }}"
        state: latest
      with_items:
        - nfs-common

    - name: create mount point
      file:
        path: /mnt/home
        state: directory
        mode: 0777
        owner: ubuntu
        group: ubuntu

    - name: mount nfs share (homedirs)
      mount:
        name: /mnt/home
        src: "{{ hostvars.localhost.jump_hosts.instances[0].private_ip_address }}:/"
        fstype: nfs
        state: mounted

    - name: create user accounts
      user:
        name: "{{ item.name }}"
        password: "{{ item.hash }}"
        group: "{{ item.group }}"
        uid: "{{ item.uid }}"
        shell: /bin/bash
        createhome: False
        home: "/mnt/home/{{ item.name }}"
      with_items: "{{ users }}"

